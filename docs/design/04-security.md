# 4. セキュリティ設計

## 4.1 暗号化方式

### 4.1.1 機密情報の暗号化

**方式**: AES-256-GCM (対称鍵暗号)

- **認証付き暗号化**: データの改ざん検出が可能
- **GCM モード**: Galois/Counter Mode (並列処理可能、高速)
- **キー長**: 256 bit (32 bytes)
- **IV (Initialization Vector)**: 12 bytes (ランダム生成)
- **Auth Tag**: 16 bytes (認証タグ)

**暗号化フロー**:

1. IV (Initialization Vector) をランダム生成
2. AES-256-GCM で暗号化
3. Auth Tag (認証タグ) を取得
4. IV + Auth Tag + 暗号化データを Base64 エンコードして返却

**復号化フロー**:

1. Base64 エンコードされたデータをデコード
2. AES-256-GCM で復号化 (Auth Tag で改ざん検証)
3. 平文を返却

### 4.1.2 マスターキーの管理

**環境変数での管理**:

```bash
# 32 バイトの hex 文字列 (64 文字)
export VAULTKEY_MASTER_KEY="0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
```

**生成方法**:

```bash
# Node.js で生成
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"

# または OpenSSL で生成
openssl rand -hex 32
```

**セキュリティ要件**:

- マスターキーはコードリポジトリに含めない
- `.env` ファイルを `.gitignore` に追加
- 本番環境では環境変数または専用のシークレット管理サービスを使用

### 4.1.3 トークンの保存

**方式**: SHA-256 ハッシュ

- **トークン生成**: `crypto.randomBytes(32)` (256 bit)
- **エンコード**: Base64 URL-safe
- **ハッシュ化**: SHA-256
- **保存**: ハッシュ値のみを DB に保存

**トークン生成フロー**:

1. `crypto.randomBytes(32)` でランダムバイト列を生成
2. Base64 URL-safe エンコード

**トークンハッシュ化フロー**:

1. SHA-256 でハッシュ化
2. Hex 文字列として返却

**検証フロー**:

1. トークンを SHA-256 でハッシュ化
2. DB からトークン情報を取得
3. トークンの存在確認
4. 有効期限チェック
5. 無効化チェック (`is_revoked` フラグ)
6. ユーザー ID を返却

## 4.2 認証設計 (WebAuthn)

### 4.2.1 Passkey 認証の概要

VaultKey は **Passkey (WebAuthn)** による強固な多要素認証を実装します。

- **公開鍵暗号**: 公開鍵を DB に保存、秘密鍵はユーザーのデバイスに保存
- **フィッシング耐性**: チャレンジ・レスポンス認証により、リプレイ攻撃を防止
- **生体認証**: 指紋、顔認証などをサポート (デバイス依存)

### 4.2.2 登録フロー

1. 登録オプション生成
   - Relying Party ID: 'localhost' (本番環境ではドメイン名)
   - Relying Party Name: 'VaultKey'
   - ユーザー ID とユーザー名
   - ランダムチャレンジの生成
   - Attestation Type: 'none' (認証器の証明は不要)
   - Authenticator Selection:
     - residentKey: 'preferred' (デバイスに Passkey を保存)
     - userVerification: 'preferred' (生体認証を推奨)

2. クライアントで Passkey 作成 (ブラウザ/CLI)
   - `navigator.credentials.create()` を使用

3. 登録レスポンスの検証
   - チャレンジの一致確認
   - オリジンの検証

4. 公開鍵を DB に保存
   - user_id, credential_id, public_key を保存

### 4.2.3 認証フロー

1. 認証オプション生成
   - Relying Party ID: 'localhost'
   - ランダムチャレンジの生成
   - 許可する認証情報リスト (credential_id, type: 'public-key')
   - userVerification: 'preferred'

2. クライアントで署名 (ブラウザ/CLI)
   - `navigator.credentials.get()` を使用

3. 認証レスポンスの検証
   - チャレンジの一致確認
   - オリジンの検証
   - 公開鍵を使った署名検証
   - カウンター検証 (Phase 1 では使用しない)

4. トークン発行
   - デフォルト有効期限: 1 時間

### 4.2.4 認証 UX の実装

#### ブラウザ自動起動方式 (デフォルト)

1. CLI から認証サーバーを起動 (デフォルト: `http://localhost:5432`、環境変数 `VAULTKEY_AUTH_PORT` で変更可能)
2. ブラウザを自動起動して認証ページを開く
3. ブラウザで Passkey 認証を実行
4. 認証成功後、トークンを CLI に返却
5. トークンを `~/.vaultkey/token` に保存
6. 認証サーバーを停止

#### 手動コピー方式 (WSL など)

1. CLI から認証サーバーを起動 (デフォルト: `http://localhost:5432`、環境変数 `VAULTKEY_AUTH_PORT` で変更可能)
2. 認証 URL を CLI に表示
3. ユーザーが手動でブラウザを開いて URL にアクセス
4. ブラウザで Passkey 認証を実行
5. 認証成功後、トークンをブラウザに表示
6. ユーザーがトークンをコピー
7. CLI にトークンを貼り付け
8. トークンを `~/.vaultkey/token` に保存
9. 認証サーバーを停止

## 4.3 認可設計

### 4.3.1 権限モデル

VaultKey は**ユーザーごとに完全に分離された権限モデル**を採用します。

- すべてのユーザーは対等な権限を持つ (管理者・一般ユーザーの区別なし)
- 各ユーザーは自分が作成した機密情報のみにアクセス可能 (CRUD)
- 他のユーザーが作成した機密情報には一切アクセスできない

### 4.3.2 アクセス制御フロー

機密情報取得時のアクセス制御:

1. トークンを検証してユーザー ID を取得
2. ユーザー ID とキーで機密情報を検索
3. 機密情報が見つからない場合はエラー
4. 所有権チェック (user_id 一致確認)
5. 有効期限チェック (`expires_at`)
6. 復号化して返却

### 4.3.3 データベースレベルの分離

```sql
-- 複合主キーによる名前空間分離
CREATE TABLE secrets (
    user_id TEXT NOT NULL,
    key TEXT NOT NULL,
    PRIMARY KEY (user_id, key),
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);

-- ユーザー削除時に機密情報も削除される (CASCADE DELETE)
```

## 4.4 脅威モデルとセキュリティ対策

### 4.4.1 脅威 1: 不正アクセス

**影響**: 機密情報の漏洩

**対策**:
- Passkey (WebAuthn) による強固な多要素認証
- トークンの有効期限 (デフォルト: 1 時間)
- 監査ログの記録

### 4.4.2 脅威 2: トークン漏洩

**影響**: なりすましによる機密情報へのアクセス

**対策**:
- トークンのハッシュ化 (SHA-256)
- 短い有効期限
- 即座の無効化機能 (`vaultkey token revoke`)
- トークン数制限 (デフォルト: 5 個)

### 4.4.3 脅威 3: データベース侵害

**影響**: 保存された機密情報の漏洩

**対策**:
- 暗号化保存 (AES-256-GCM)
- マスターキーの分離管理 (環境変数)
- データベースファイルのアクセス権限設定 (600)

### 4.4.4 脅威 4: リプレイ攻撃

**影響**: 過去の認証情報の再利用

**対策**:
- チャレンジ・レスポンス認証 (WebAuthn)
- ランダムチャレンジの使用
- タイムスタンプによる有効期限チェック

### 4.4.5 脅威 5: ライブラリの脆弱性

**影響**: アプリケーション全体のセキュリティ侵害

**対策**:
- 定期的な依存ライブラリの更新
- セキュリティ監査の実施
- npm audit の定期実行

## 4.5 セキュリティベストプラクティス

### 4.5.1 機密情報の取り扱い

**絶対に記録しない**:
- 機密情報の値
- トークン (平文)
- パスワード
- 暗号化キー

**記録可能**:
- ユーザー ID、キー名、アクション種別、タイムスタンプ
- エラーメッセージ (機密情報を含まない)

### 4.5.2 エラーメッセージの設計

**適切なエラーメッセージ**:
- 機密情報を含まない汎用的なメッセージ
- 例: '機密情報が見つかりません'
- 例: 'トークンが無効です'

**不適切なエラーメッセージ**:
- キー名、ユーザー ID、トークンなどの具体的な値を含むメッセージ
- 例: '機密情報 "api_key" が見つかりません' (NG)
- 例: 'ユーザー user123 のトークンが無効です' (NG)

### 4.5.3 メモリ上の機密情報の破棄

機密情報を使用後速やかに破棄する方針:

- 復号化された機密情報は必要最小限の期間のみメモリに保持
- 使用後は速やかに参照を削除 (null 代入など)
- try-finally ブロックで確実に破棄処理を実行

### 4.5.4 データベースファイルのアクセス権限

```bash
# データベースファイルの作成時に権限を設定
chmod 600 vaultkey.db

# トークンファイルの権限設定
chmod 600 ~/.vaultkey/token
```

### 4.5.5 定期的なセキュリティチェック

```bash
# 依存ライブラリの脆弱性チェック
npm audit

# 依存ライブラリの更新
npm update

# セキュリティパッチの適用
npm audit fix
```
