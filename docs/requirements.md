# VaultKey - 要件定義書

## 1. 概要

VaultKey は、機密情報を安全に管理するためのライブラリおよび CLI ツールです。プログラムから直接利用できるライブラリインターフェースと、コマンドラインから操作できる CLI を提供します。

## 2. 目的

### 2.1 ビジネス目的
- アプリケーションが必要な機密情報 (API キー、パスワード、トークンなど) に安全にアクセスできるようにする
- 機密情報への不正アクセスを防止する
- 機密情報の使用履歴を追跡可能にする

### 2.2 解決すべき課題
- 現状、アプリケーションで機密情報を扱う際に環境変数やハードコーディングに頼っている
- 機密情報のローテーションや管理が困難
- 誰が、いつ、何にアクセスしたかを追跡できない
- 複数のアプリケーション間で機密情報を安全に共有できない

## 3. ステークホルダー

### 3.1 ユーザーの種類
- **ユーザー**: 自分が作成した機密情報の CRUD 操作を実施
- **アプリケーション開発者**: VaultKey ライブラリをプログラムから利用
- **システム管理者**: CLI から機密情報を管理

### 3.2 権限モデル
- すべてのユーザーは対等な権限を持つ（管理者・一般ユーザーの区別なし）
- 各ユーザーは自分が作成した機密情報のみにアクセス可能（CRUD）
- 他のユーザーが作成した機密情報には一切アクセスできない
- 機密情報のキーはユーザーごとに名前空間が分離される

## 4. 機能要件

### 4.1 機密情報管理

#### FR-1.1 機密情報の保存
- **要件**: ユーザーが機密情報をキーと値のペアで保存できること
- **アクター**: ユーザー
- **前提条件**: 有効なトークンが存在する
- **入力**:
  - キー (必須)
  - 値 (必須)
  - 有効期限 (オプション)
- **成功条件**: 機密情報が安全に保存され、以下のメタデータが記録される
  - 作成日時
  - 作成者 (ユーザー ID)
  - 有効期限 (指定された場合)
  - 最終更新日時
  - 最終更新者
  - 最終アクセス日時
- **失敗条件**:
  - トークンが無効または期限切れ
  - 同じユーザーで同じキーが既に存在する

#### FR-1.2 機密情報の取得
- **要件**: 有効なトークンを持つユーザーが自分の機密情報を取得できること
- **アクター**: ユーザー、アプリケーション
- **前提条件**: 有効なアクセストークンが存在する
- **成功条件**: 指定されたキーの機密情報が返され、最終アクセス日時が更新される
- **失敗条件**:
  - トークンが無効または期限切れ
  - キーが存在しない（自分が作成したキーの中に存在しない）
  - トークンが無効化されている
  - 機密情報の有効期限が切れている
- **備考**: 他のユーザーが作成した機密情報には一切アクセスできない

#### FR-1.3 機密情報の更新
- **要件**: ユーザーが自分の既存の機密情報を更新できること
- **アクター**: ユーザー
- **前提条件**:
  - 有効なトークンが存在する
  - 更新対象のキーが存在する（自分が作成したキー）
- **入力**:
  - キー (必須)
  - 値 (必須)
  - 有効期限 (オプション)
- **成功条件**: 機密情報が更新され、以下のメタデータが更新される
  - 最終更新日時
  - 最終更新者 (ユーザー ID)
  - 有効期限 (指定された場合)

#### FR-1.4 機密情報の削除
- **要件**: ユーザーが自分の機密情報を削除できること
- **アクター**: ユーザー
- **前提条件**:
  - 有効なトークンが存在する
  - 削除対象のキーが存在する（自分が作成したキー）
- **成功条件**: 機密情報が完全に削除される

#### FR-1.5 機密情報のキー一覧取得
- **要件**: ユーザーが自分が保存した機密情報のキー一覧を取得できること
- **アクター**: ユーザー
- **前提条件**: 有効なアクセストークンが存在する
- **成功条件**: 自分の機密情報のキーリストが返される (値は含まない)
- **オプション**: パターンマッチによるフィルタリング
- **備考**: 他のユーザーの機密情報は一覧に表示されない

#### FR-1.6 有効期限管理
- **要件**: ユーザーが自分の機密情報の有効期限を管理できること
- **アクター**: ユーザー
- **機能**:
  - 有効期限切れ間近 (例: 7 日以内) の自分の機密情報を一覧表示
  - 有効期限切れの自分の機密情報を一覧表示
  - 有効期限切れの自分の機密情報を削除するコマンド
- **前提条件**: 有効なアクセストークンが存在する
- **成功条件**: 指定された条件に合致する自分の機密情報の一覧が返される

### 4.2 ユーザー認証

#### FR-2.1 ユーザー登録
- **要件**: 新規ユーザーが Passkey を使って登録できること
- **アクター**: 新規ユーザー
- **入力**: ユーザー ID、ユーザー名
- **成功条件**:
  - ユーザーアカウントが作成される
  - Passkey 認証情報が1つ登録される (1 ユーザー = 1 Passkey)
  - 作成日時が記録される
- **失敗条件**:
  - ユーザー ID またはユーザー名が既に存在する
  - Passkey 作成に失敗
- **備考**:
  - Phase 1 では 1 ユーザーにつき 1 つの Passkey のみ登録可能
  - ユーザー登録は誰でも自由に実行可能（セルフ登録）

#### FR-2.2 ユーザー認証
- **要件**: 登録済みユーザーが Passkey を使って認証できること
- **アクター**: 登録済みユーザー
- **入力**: ユーザー ID
- **認証 UX**:
  - **デフォルト**: ブラウザ自動起動
    - CLI がブラウザを自動的に開く
    - ブラウザで Passkey 認証を実行
    - 認証成功後、ブラウザを閉じて CLI に戻る
  - **WSL などブラウザ自動起動できない環境**: 手動コピー方式
    - CLI が認証 URL を表示
    - ユーザーが手動でブラウザを開いて URL にアクセス
    - Passkey 認証後、ブラウザにトークンが表示される
    - ユーザーがトークンをコピーして CLI に貼り付け
    - CLI が処理を続行
- **成功条件**:
  - 認証が成功する
  - アクセストークンが発行される
  - ログイン日時が記録される
- **失敗条件**:
  - ユーザーが存在しない
  - Passkey 認証に失敗
- **備考**: Claude Code と同様の認証 UX を提供

### 4.3 トークン管理

#### FR-3.1 トークン発行
- **要件**: 認証成功後、時間制限付きアクセストークンが発行されること
- **前提条件**: Passkey 認証が成功している
- **入力**:
  - ユーザー ID
  - 有効期限 (時間単位、デフォルト: 1 時間)
- **成功条件**:
  - アクセストークンが生成される
  - トークン情報がデータベースに記録される
  - 有効期限が設定される
- **制約**:
  - 1 ユーザーあたりのトークン数制限 (設定可能、デフォルト: 5個)
  - 制限を超える場合、最も古いトークンが自動的に無効化される
- **備考**:
  - トークンはユーザー識別のためのものであり、機密情報の値の読み取り専用アクセスを提供する
  - トークン自体は権限を決定せず、トークンに紐づくユーザーが作成した機密情報のみにアクセス可能
  - Phase 1 ではトークンのスコープ設定は不要
  - リフレッシュトークン機能は Phase 1 では不要 (将来的な拡張候補)

#### FR-3.2 トークン検証
- **要件**: API リクエスト時にトークンの有効性が検証されること
- **検証項目**:
  - トークンが存在する
  - 有効期限内である
  - 無効化されていない
- **成功条件**: トークンが有効である
- **失敗条件**: 上記のいずれかの条件を満たさない

#### FR-3.3 トークン無効化
- **要件**: ユーザーが自分のトークンを無効化できること
- **アクター**: 管理者、一般ユーザー
- **ユースケース**:
  - ログアウト
  - セキュリティ侵害時の緊急対応
- **成功条件**: トークンが即座に無効化される

#### FR-3.4 トークン一覧取得
- **要件**: ユーザーが自分の有効なトークン一覧を確認できること
- **アクター**: 管理者、一般ユーザー
- **成功条件**: 自分に紐づく有効なトークンの情報 (ハッシュ、作成日時、有効期限) が返される

### 4.4 監査とログ

#### FR-4.1 アクセスログの記録
- **要件**: すべての機密情報へのアクセスが記録されること
- **記録内容**:
  - 誰が (ユーザー ID)
  - いつ (タイムスタンプ)
  - 何を (アクション: get/store/update/delete)
  - どのリソースに (キー)
  - 成功/失敗
  - 失敗時のエラーメッセージ
- **保持期間**: 推奨 90 日間以上（自動削除・アーカイブ・容量制限機能は提供しない）
- **備考**:
  - すべてのユーザーの操作を共通のログファイルに出力
  - ログ管理（削除・アーカイブ・容量制限）はユーザー側で実施

#### FR-4.2 監査ログの検索
- **要件**: ユーザーが監査ログを検索・閲覧できること
- **アクター**: ユーザー
- **検索条件**: ユーザー ID、日時範囲、アクション種別、リソースキー
- **備考**: Phase 3 で実装予定

### 4.5 ライブラリインターフェース

#### FR-5.1 ライブラリとしての提供
- **要件**: プログラムから VaultKey を利用できること
- **提供 API**:
  - クライアントクラスのインスタンス化
  - `getSecret(key, token)`: 機密情報取得
  - `storeSecret(key, value, token, expiresAt?)`: 機密情報保存 (有効期限オプション)
  - `updateSecret(key, value, token, expiresAt?)`: 機密情報更新 (有効期限オプション)
  - `deleteSecret(key, token)`: 機密情報削除
  - `listSecrets(token, pattern?)`: キー一覧取得
  - `listExpiringSecrets(token, daysUntilExpiry)`: 有効期限切れ間近の機密情報一覧
  - `listExpiredSecrets(token)`: 有効期限切れの機密情報一覧
  - `deleteExpiredSecrets(token)`: 有効期限切れの機密情報削除
  - `revokeToken(token)`: トークン無効化
  - `listTokens(token)`: トークン一覧取得

#### FR-5.2 エラーハンドリング
- **要件**: すべてのエラーを適切な形式で通知すること
- **エラー種別**:
  - 認証エラー
  - 権限エラー
  - リソース未検出
  - バリデーションエラー
  - リソース競合
  - その他のエラー

### 4.6 CLI インターフェース

#### FR-6.1 CLI としての提供
- **要件**: コマンドラインから VaultKey を操作できること
- **提供コマンド**:
  - `init`: データベース初期化
  - `user register`: ユーザー登録
  - `user login`: ユーザー認証・トークン発行
  - `secret get <key>`: 機密情報取得
  - `secret set <key> [--expires-in <duration>]`: 機密情報保存（値は対話的に入力、有効期限オプション）
  - `secret update <key> [--expires-in <duration>]`: 機密情報更新（値は対話的に入力、有効期限オプション）
  - `secret delete <key> [--force]`: 機密情報削除（確認ダイアログあり、`--force` で確認スキップ）
  - `secret list [--pattern <pattern>]`: キー一覧取得
  - `secret list-expiring [--days <days>]`: 有効期限切れ間近の機密情報一覧
  - `secret list-expired`: 有効期限切れの機密情報一覧
  - `secret cleanup-expired [--force]`: 有効期限切れの機密情報削除（確認ダイアログあり）
  - `token revoke <token>`: トークン無効化
  - `token list`: トークン一覧取得
  - `audit search`: 監査ログ検索

#### FR-6.2 トークンの扱い
- **要件**: CLI でトークンを安全に扱えること
- **方式**:
  - トークンは環境変数から読み込み
  - または `--token` オプションで指定
  - トークンファイルからの読み込みも可能

#### FR-6.3 出力フォーマット
- **要件**: CLI の出力フォーマットを選択できること
- **フォーマット**:
  - `--format json`: JSON 形式
  - `--format yaml`: YAML 形式
  - デフォルト: 人間が読みやすいテーブル形式

#### FR-6.4 対話的入力
- **要件**: 機密情報の値を対話的に入力できること
- **方式**:
  - `secret set` および `secret update` コマンドでは値を引数で指定しない
  - コマンド実行後、対話的にパスワード入力プロンプトが表示される
  - 入力された値はマスク表示され、コマンド履歴に残らない
- **例**:
  ```bash
  vaultkey secret set api_key
  Enter value: ********  # ユーザーが入力（マスク表示）
  ```

#### FR-6.5 確認ダイアログ
- **要件**: 危険な操作には確認ダイアログを表示すること
- **対象操作**:
  - `secret delete`: 機密情報の削除
  - `secret cleanup-expired`: 有効期限切れ機密情報の一括削除
- **方式**:
  - デフォルトで確認ダイアログを表示
  - `--force` オプションで確認をスキップ可能
- **例**:
  ```bash
  vaultkey secret delete api_key
  Are you sure you want to delete 'api_key'? (y/N):
  ```

## 5. 非機能要件

### 5.1 セキュリティ要件

#### NFR-1.1 データ保護
- すべての機密情報は暗号化して保存すること
- 暗号化キーはコードから分離して管理すること
- トークンはハッシュ化して保存すること

#### NFR-1.2 認証・認可
- Passkey (WebAuthn) による強固な多要素認証を実装すること
- トークンベースのアクセス制御を実装すること
- ユーザーごとに機密情報を完全に分離すること
- トークン数の制限（設定可能、デフォルト: 5 個）を実装すること

#### NFR-1.3 機密情報の取り扱い
- ログに機密情報 (値、トークン、パスワード) を記録しないこと
- エラーメッセージから機密情報を除外すること
- メモリ上の機密情報は使用後速やかに破棄すること

### 5.2 保守性要件

#### NFR-2.1 ログ
- 構造化ログを出力すること
- ログレベルを適切に使い分けること

#### NFR-2.2 モニタリング
- 以下のメトリクスを記録すること:
  - トークン発行数
  - 機密情報アクセス数
  - エラー発生率

#### NFR-2.3 アラート
- 以下の条件でログに警告を記録すること:
  - 連続する認証失敗 (5 回以上)
  - 異常なアクセスパターン
  - システムエラーの発生

#### NFR-2.4 エラーハンドリング
- 一時的なエラー（データベース接続失敗など）は自動的にリトライすること
- リトライ回数と間隔は設定可能とすること

### 5.3 互換性要件

#### NFR-3.1 OS 互換性
- Linux、macOS、Windows で動作すること

#### NFR-3.2 パッケージ管理
- 標準的なパッケージマネージャーで配布可能であること

## 6. 制約条件

### 6.1 技術制約
- データベースは SQLite (開発・小規模利用) と PostgreSQL (本番・大規模利用) をサポートすること

### 6.2 セキュリティ制約
- 暗号化マスターキーはコードリポジトリに含めないこと
- マスターキーは環境変数 `VAULTKEY_MASTER_KEY` で管理すること
- 本番環境では環境変数または専用のシークレット管理サービスを使用すること

### 6.3 配布制約
- パッケージレジストリで配布すること

### 6.4 初期セットアップ制約
- マスターキーは環境変数で事前に設定する必要がある
- マスターキーのローテーション機能は Phase 1 では提供しない

## 7. 開発フェーズ

### Phase 1: MVP (最小限の機能)
- 機密情報の暗号化保存・取得
- 基本的なトークン管理 (発行・検証)
- ライブラリインターフェース
- 基本的な CLI コマンド
- SQLite ベースの実装

### Phase 2: 認証強化
- Passkey 認証の実装
- ユーザー管理機能
- 監査ログの記録
- トークン数制限の実装
- 有効期限管理機能

### Phase 3: CLI 拡張
- 高度な CLI 機能 (フォーマット選択、対話的入力、確認ダイアログ)
- 監査ログ検索機能

### Phase 4: 本番対応
- PostgreSQL への移行
- セキュリティ監査
- ドキュメント整備

## 8. セキュリティ考慮事項

### 8.1 脅威モデル

#### 脅威 1: 不正アクセス
- **影響**: 機密情報の漏洩
- **対策**: Passkey 認証、トークンの有効期限、監査ログ

#### 脅威 2: トークン漏洩
- **影響**: なりすましによる機密情報へのアクセス
- **対策**: トークンのハッシュ化、短い有効期限、即座の無効化機能

#### 脅威 3: データベース侵害
- **影響**: 保存された機密情報の漏洩
- **対策**: 暗号化保存、マスターキーの分離管理

#### 脅威 4: リプレイ攻撃
- **影響**: 過去の認証情報の再利用
- **対策**: チャレンジ・レスポンス認証 (WebAuthn)

#### 脅威 5: ライブラリの脆弱性
- **影響**: アプリケーション全体のセキュリティ侵害
- **対策**: 定期的な依存ライブラリの更新、セキュリティ監査

### 8.2 セキュリティベストプラクティス
1. マスターキーは環境変数で管理、コードに含めない
2. すべてのエラーメッセージから機密情報を除外
3. ログには機密情報を記録しない
4. 定期的なセキュリティ監査の実施
5. 依存ライブラリの定期的な更新

## 9. 受け入れ基準

### 9.1 Phase 1 完了基準
- [ ] 機密情報の保存・取得ができる
- [ ] 機密情報が暗号化されて保存される
- [ ] トークンによるアクセス制御が機能する
- [ ] プログラムから利用できる
- [ ] 基本的な CLI コマンドが動作する
- [ ] すべてのユニットテストが通過する

### 9.2 Phase 2 完了基準
- [ ] Passkey 認証が機能する
- [ ] ユーザー登録・認証フローが完成している（Claude Code と同様の UX）
- [ ] ユーザーごとに機密情報が完全に分離されている
- [ ] 監査ログが記録される
- [ ] トークン数制限が機能する
- [ ] 有効期限管理機能が動作する

### 9.3 Phase 3 完了基準
- [ ] CLI から高度な操作ができる
- [ ] 対話的入力・確認ダイアログが機能する
- [ ] 監査ログを検索できる

### 9.4 Phase 4 完了基準
- [ ] PostgreSQL で動作する
- [ ] セキュリティ監査に合格する
- [ ] ドキュメントが完備されている
- [ ] パッケージレジストリで公開されている

## 10. 参考資料

- [WebAuthn Specification](https://www.w3.org/TR/webauthn/)
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
